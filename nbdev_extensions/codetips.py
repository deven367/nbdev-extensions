# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_codetips.ipynb.

# %% auto 0
__all__ = ['HINT_CSS_URL', 'TIPS_CSS', 'download_tooltip_css', 'write_tooltip_directives', 'convert_explanation', 'extract_code',
           'parse_code', 'TipExportProc', 'parse_notes']

# %% ../nbs/03_codetips.ipynb 3
from nbdev.config import get_config
from nbdev.process import NBProcessor, extract_directives
from nbdev.processors import Processor, mk_cell
from nbdev.export import nb_export
from nbdev.doclinks import nbglob
from nbdev.sync import write_nb

from fastcore.script import call_parse
from fastcore.xtras import Path

import shlex
import requests
import re

# %% ../nbs/03_codetips.ipynb 5
HINT_CSS_URL = "https://raw.githubusercontent.com/muellerzr/til/master/nbs/hint.css"

# %% ../nbs/03_codetips.ipynb 6
TIPS_CSS = """.nogap {
    padding: 0px;
    border-radius: 0px !important;
    outline: 0px 0px;
    margin-bottom: 0px !important;
}

.code-with-filename .code-with-filename-file {
    margin: 0px;
}
div.sourceCode {
    border: 0px;
    margin: 0px;
}

pre > code.sourceCode {
    white-space: pre;
    text-decoration: none;
}

.nogap > div.sourceCode > pre.sourceCode {
    line-height: 0px;
    padding-bottom: 0px;
    padding-top: 0px;
    margin-bottom: 0px;
    margin-top: 0px;
}"""

# %% ../nbs/03_codetips.ipynb 7
def download_tooltip_css():
    config = get_config()
    css_path = config.nbs_path/"hint.css"
    if not css_path.exists():
        response = requests.get(HTML_CSS_URL)
        css_path.write_bytes(response.content)
        (config.nbs_path/"codetips.css").write_text(TIPS_CSS)
        print(f'Added custom css files. Please add `codetips.css` and `hint.css` to `_quarto.yml` under `format -> html -> css`')

# %% ../nbs/03_codetips.ipynb 8
def write_tooltip_directives(
    # The tooltip text
    explanation: str,
    # A list of css directives to modify the tooltip
    hint_directives:list = ["rounded", "medium", "right"],
    # An optional filename to be rendered 
    filename:str = None,
):
    "Creates a tooltip in style of `hint_directives` with content `explanation`"
    hint_directives = [f".hint--{hint} " for hint in hint_directives]
    hint_directives[-1] = hint_directives[-1].rstrip() # for formatting
    tooltip = f'''#| classes: .nogap {"".join(hint_directives)}
#| aria-label: "{explanation}"
#|eval: false'''
    if filename is not None:
        tooltip += f'\n#| filename: "{filename}"'
    return tooltip + "\n"

# %% ../nbs/03_codetips.ipynb 9
def convert_explanation(explanation_cell, source):
    "Takes an explanation and source code and linkes them together in a new cell"
    filename = explanation_cell.directives_.pop("filename:", [None])[0]
    explanation = re.sub(r'\*#|.*[\n]', "", explanation_cell.source)
    content = write_tooltip_directives(explanation, filename=filename)
    content += source
    return mk_cell(content, cell_type="code")

# %% ../nbs/03_codetips.ipynb 10
def extract_code(start_code, end_code, source, instance_num, end_instance_num=0):
    "Finds code between start and finish potentially with instances to check"
    start_match = list(re.finditer(f'[ \t]*{start_code}', source))[int(instance_num)]
    start_char = start_match.span()[0]
    end_match = list(re.finditer(f'[ \t]*{end_code}', source))[int(end_instance_num)]
    end_char = end_match.span()[1]
    return source[start_char:end_char], start_char, end_char

# %% ../nbs/03_codetips.ipynb 11
def parse_code(code_cell, markdown_cell):
    "Parses directives to extract the code needed to be highlighted"
    directives = markdown_cell.directives_["tip"]
    directives = shlex.split(" ".join(directives))
    if len(directives) == 4:
        start_code, start_instance_num, end_code, end_instance_num = directives
    else:
        (start_code, start_instance_num, end_code), (end_instance_num) = directives, 0
    start_code, end_code = re.escape(start_code), re.escape(end_code)
    return extract_code(start_code, end_code, code_cell.source, start_instance_num, end_instance_num)

# %% ../nbs/03_codetips.ipynb 12
class TipExportProc(Processor):
    "A proc that checks and reorganizes cells for documentation for proper explainations"
    offset = 0
    steps = []
    _i = 0
    def begin(self):
        self.reset()
        self.has_reset = False
        self.iter = 0
        self.offset = 0
    
    def reset(self):
        self.results = [mk_cell("::: {layout-ncol=1}", cell_type="markdown")]    
        self.code = []
        self._code = None
        self.found_explanation = False
        self.end_link = False
        self.explanations = []
        self.start_idx = None
        self.end_idx = None
        self.indexes = []
    
    def cell(self, cell):
        if cell.cell_type == "code":
            if not self.found_explanation:
                self._code = cell
                self.start_idx = cell.idx_
                
        if cell.cell_type == "markdown" and "tip" in cell.directives_:
            self.found_explanation = True
            self.explanations.append(cell)
            
        if self.found_explanation:
            idx = cell.idx_ + 1
            if (len(self.nb.cells) <= idx+1) or ("tip" not in self.nb.cells[idx].directives_):
                self.end_link = True
                self.end_idx = cell.idx_ + 1
        
        if self.found_explanation and self.end_link:
            # Assume we have all code + explainations
            explanations = [self._code]
            for i,explanation in enumerate(self.explanations):
                source, start, end = parse_code(self._code, explanation)
                self.indexes += [(start,end)]
                converted_explanation = convert_explanation(explanation, source)
                self.results.append(converted_explanation)
                self.nb.cells.remove(explanation)
            second_idxs = list(self.indexes)
            second_idxs.sort()
            offset = 0
            for idx, rng in enumerate(second_idxs):
                if rng != second_idxs[-1]:
                    if second_idxs[idx+1][0] - rng[-1] != 1:
                        start = rng[-1]
                        end = second_idxs[idx+1][0]
                        new_src = self._code.source[start:end]
                        if new_src != '':
                            new_src = f'#| classes: .nogap\n#|eval: false\n{new_src}'
                            self.results.insert(self.indexes.index(rng)+2, mk_cell(new_src, cell_type="code"))
                            offset += 1
            self.results.append(mk_cell(":::", cell_type="markdown"))
            self.nb.cells.remove(self._code)
            self.offset = 0
            for result in self.results:
                result.idx_ = self.nb.cells[self.start_idx - 1].idx_ + 1
                self.nb.cells.insert(self.start_idx + self.offset, result)
                self.offset += 1
            self.iter += 1
            self.reset()
            self.has_reset = True
            
            self.offset = 0
            for i,c in enumerate(self.nb.cells): c.idx_ = i

# %% ../nbs/03_codetips.ipynb 13
@call_parse
def parse_notes():
    "Exports notebooks to parsed notes for documentation. Should be called in the workflow, not yourself!"
    for nb in nbglob(get_config().nbs_path):
        processor = NBProcessor(nb, [NoteExportProc], rm_directives=False)
        processor.process()
        write_nb(processor.nb, nb)
